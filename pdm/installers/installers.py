from __future__ import annotations

import pathlib
import sys
from typing import TYPE_CHECKING

from installer.destinations import SchemeDictionaryDestination
from installer.exceptions import InvalidWheelSource
from installer.sources import WheelFile as _WheelFile

from pdm import termui
from pdm.exceptions import UninstallError
from pdm.installers.uninstallers import BaseRemovePaths, StashedRemovePaths
from pdm.models import pip_shims
from pdm.utils import cached_property, is_dist_editable

if TYPE_CHECKING:
    from typing import BinaryIO

    from installer.destinations import Scheme
    from installer.records import RecordEntry
    from pip._vendor.pkg_resources import Distribution

    from pdm.models.candidates import Candidate
    from pdm.models.environment import Environment


def format_dist(dist: Distribution) -> str:
    formatter = "{version}{path}"
    path = ""
    if is_dist_editable(dist):
        path = f" (-e {dist.location})"
    return formatter.format(version=termui.yellow(dist.version), path=path)


class WheelFile(_WheelFile):
    @cached_property
    def dist_info_dir(self) -> str:
        namelist = self._zipfile.namelist()
        try:
            return next(
                name.split("/")[0]
                for name in namelist
                if name.split("/")[0].endswith(".dist-info")
            )
        except StopIteration:  # pragma: no cover
            canonical_name = super().dist_info_dir
            raise InvalidWheelSource(
                f"The wheel doesn't contain metadata {canonical_name!r}"
            )


class InstallDestination(SchemeDictionaryDestination):
    def write_to_fs(
        self, scheme: Scheme, path: str | pathlib.Path, stream: BinaryIO
    ) -> RecordEntry:
        target_path = pathlib.Path(self.scheme_dict[scheme], path)
        if target_path.exists():
            target_path.unlink()
        return super().write_to_fs(scheme, path, stream)


class Installer:  # pragma: no cover
    """The installer that performs the installation and uninstallation actions."""

    def __init__(self, environment: Environment) -> None:
        self.environment = environment

    def install(self, candidate: Candidate) -> None:
        if candidate.req.editable:
            self.install_editable(candidate.ireq)
        else:
            built = candidate.build()
            self.install_wheel(built)

    def install_wheel(self, wheel: str) -> None:
        from installer import __version__, install

        destination = InstallDestination(
            self.environment.get_paths(),
            interpreter=self.environment.interpreter.executable,
            script_kind=self._get_kind(),
        )

        with WheelFile.open(wheel) as source:
            install(
                source=source,
                destination=destination,
                # Additional metadata that is generated by the installation tool.
                additional_metadata={
                    "INSTALLER": f"installer {__version__}".encode(),
                },
            )

    def install_editable(self, ireq: pip_shims.InstallRequirement) -> None:
        from pdm.builders import EditableBuilder

        builder = EditableBuilder(ireq.unpacked_source_directory, self.environment)
        setup_path = builder.ensure_setup_py()
        paths = self.environment.get_paths()
        install_script = pathlib.Path(__file__).with_name("_editable_install.py")
        install_args = [
            self.environment.interpreter.executable,
            "-u",
            str(install_script),
            setup_path,
            paths["prefix"],
            paths["purelib"],
            paths["scripts"],
        ]
        builder.install(["setuptools"])
        builder.subprocess_runner(install_args, ireq.unpacked_source_directory)

    def get_paths_to_remove(self, dist: Distribution) -> BaseRemovePaths:
        return StashedRemovePaths.from_dist(dist, envrionment=self.environment)

    def uninstall(self, dist: Distribution) -> None:
        remove_path = self.get_paths_to_remove(dist)
        try:
            remove_path.remove()
            remove_path.commit()
        except OSError as e:
            remove_path.rollback()
            raise UninstallError(e) from e

    def _get_kind(self) -> str:
        if sys.platform != "win32":
            return "posix"
        is_32bit = self.environment.interpreter.is_32bit
        # TODO: support win arm64
        if is_32bit:
            return "win-ia32"
        else:
            return "win-amd64"
